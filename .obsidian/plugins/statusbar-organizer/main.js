/*
THIS IS A GENERATED/BUNDLED FILE BY ESBUILD
if you want to view the source, please visit the github repository of this plugin
*/

var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// main.ts
var main_exports = {};
__export(main_exports, {
  default: () => StatusBarOrganizer
});
module.exports = __toCommonJS(main_exports);
var import_obsidian = require("obsidian");
var ignoredClasses = [
  "mod-clickable",
  "status-bar-item",
  "statusbar-organizer-hidden"
];
function generateId(name, index) {
  return `${name};${index}`;
}
function parseId(id) {
  const parts = id.split(";");
  const index = Number.parseInt(parts.pop());
  const name = parts.join(";");
  return {
    name,
    index
  };
}
function getStatusBarElements() {
  const statusBar = document.getElementsByClassName("status-bar")[0];
  const elements = [];
  const pluginElementCount = {};
  Array.from(statusBar.children).forEach((element) => {
    let id = element.getAttribute("data-statusbar-organizer-id");
    let name, index;
    if (id == null) {
      name = Array.from(element.classList).filter((x) => !ignoredClasses.contains(x)).join("-");
      index = name in pluginElementCount ? pluginElementCount[name] + 1 : 1;
      id = generateId(name, index);
      element.setAttribute("data-statusbar-organizer-id", id);
    } else {
      const parsed = parseId(id);
      name = parsed.name;
      index = parsed.index;
    }
    pluginElementCount[name] = Math.max(
      index,
      name in pluginElementCount ? pluginElementCount[name] : 0
    );
    elements.push({
      name,
      index,
      id,
      element
    });
  });
  return elements;
}
function fixOrder(status) {
  const elements = getStatusBarElements();
  const statusBar = document.getElementsByClassName("status-bar")[0];
  const known = [];
  const orphans = [];
  for (const element of elements) {
    if (element.id in status) {
      const myStatus = status[element.id];
      known.push([element, myStatus.position]);
      if (myStatus.visible)
        element.element.removeClass("statusbar-organizer-hidden");
      else
        element.element.addClass("statusbar-organizer-hidden");
    } else {
      orphans.push(element.element);
    }
  }
  const orderedElements = known.sort((a, b) => a[1] - b[1]).map((x) => x[0].element);
  const allElements = orderedElements.concat(orphans);
  for (const [i, element] of allElements.entries())
    element.style.order = (i + 1).toString();
}
function disableObserver(plugin) {
  plugin.observer.disconnect();
}
function enableObserver(plugin) {
  plugin.observer.observe(plugin.statusBar, { childList: true });
}
function spoolFix(plugin, timeout = 1e3) {
  clearTimeout(plugin.spooler);
  plugin.spooler = window.setTimeout(() => {
    if (this.mutex) {
      spoolFix(plugin);
    } else {
      plugin.mutex = true;
      disableObserver(plugin);
      fixOrder(plugin.settings.status);
      enableObserver(plugin);
      plugin.mutex = false;
    }
  }, timeout);
}
var DEFAULT_SETTINGS = {
  status: {}
};
var StatusBarOrganizer = class extends import_obsidian.Plugin {
  async onload() {
    await this.loadSettings();
    this.addSettingTab(new StatusBarSettingTab(this.app, this));
    this.spooler = 0;
    this.mutex = false;
    this.statusBar = document.getElementsByClassName("status-bar")[0];
    this.observer = new MutationObserver((list, _) => {
      if (!this.mutex && list.some(
        (mutation) => mutation.type == "childList" && mutation.addedNodes.length > 0
      )) {
        spoolFix(this, 0);
      }
    });
    spoolFix(this, 5e3);
  }
  onunload() {
    disableObserver(this);
  }
  async loadSettings() {
    this.settings = Object.assign({}, DEFAULT_SETTINGS, await this.loadData());
  }
  async saveSettings() {
    await this.saveData(this.settings);
  }
};
var StatusBarSettingTab = class extends import_obsidian.PluginSettingTab {
  constructor(app, plugin) {
    super(app, plugin);
    this.plugin = plugin;
  }
  async display() {
    const { containerEl } = this;
    containerEl.empty();
    const entriesContainer = document.createElement("div");
    entriesContainer.addClass("statusbar-organizer-container");
    containerEl.appendChild(entriesContainer);
    const loadedElementStatus = this.plugin.settings.status;
    const unorderedStatusBarElements = getStatusBarElements();
    const defaultElementStatus = {};
    for (const [index, statusBarElement] of unorderedStatusBarElements.entries()) {
      defaultElementStatus[statusBarElement.id] = {
        position: index,
        visible: true,
        exists: true
      };
    }
    const elementStatus = {};
    for (const [index, status] of Object.entries(loadedElementStatus)) {
      status.exists = index in defaultElementStatus;
      elementStatus[index] = status;
    }
    let insertPosition = Object.keys(elementStatus).length + 1;
    for (const element of unorderedStatusBarElements) {
      if (element.id in elementStatus)
        continue;
      const status = defaultElementStatus[element.id];
      status.position = insertPosition++;
      elementStatus[element.id] = status;
    }
    const disabledStatusBarElements = Object.keys(loadedElementStatus).filter((x) => !elementStatus[x].exists).map((x) => {
      const parsed = parseId(x);
      return {
        name: parsed.name,
        index: parsed.index,
        id: x
      };
    });
    const statusBarElements = unorderedStatusBarElements.concat(disabledStatusBarElements).map((x) => [x, elementStatus[x.id].position]).sort((a, b) => a[1] - b[1]).map((x) => x[0]);
    this.plugin.settings.status = elementStatus;
    await this.plugin.saveSettings();
    spoolFix(this.plugin, 0);
    async function toggleVisibility(statusBarElement, plugin) {
      const status = elementStatus[statusBarElement.id];
      if (statusBarElement.element) {
        if (status.visible = !status.visible) {
          statusBarElement.element.removeClass("statusbar-organizer-hidden");
          (0, import_obsidian.setIcon)(statusBarElement.entry.children[3], "eye");
        } else {
          statusBarElement.element.addClass("statusbar-organizer-hidden");
          (0, import_obsidian.setIcon)(statusBarElement.entry.children[3], "eye-off");
        }
      }
      plugin.settings.status = elementStatus;
      await plugin.saveSettings();
    }
    async function removeOrphan(statusBarElement, plugin) {
      entriesContainer.removeChild(statusBarElement.entry);
      delete elementStatus[statusBarElement.id];
      for (const [entryIndex, entry] of Array.from(entriesContainer.children).entries())
        elementStatus[entry.getAttribute("data-statusbar-organizer-id")].position = entryIndex;
      plugin.settings.status = elementStatus;
      await plugin.saveSettings();
    }
    let dragging = false;
    function handleMouseDown(statusBarElement, event, plugin) {
      if (dragging)
        return;
      dragging = true;
      const realEntry = statusBarElement.entry;
      realEntry.addClass("statusbar-organizer-clone");
      const fauxEntry = document.createElement("div");
      fauxEntry.addClass("statusbar-organizer-entry");
      fauxEntry.addClass("statusbar-organizer-drag");
      containerEl.appendChild(fauxEntry);
      fauxEntry.style.left = realEntry.getBoundingClientRect().left + "px";
      fauxEntry.style.top = realEntry.getBoundingClientRect().top + "px";
      fauxEntry.style.width = realEntry.offsetWidth + "px";
      for (const child of Array.from(realEntry.children)) {
        const fauxSpan = document.createElement("span");
        fauxSpan.className = child.className;
        fauxSpan.innerHTML = child.innerHTML;
        fauxEntry.appendChild(fauxSpan);
      }
      let offsetX = event.clientX - fauxEntry.getBoundingClientRect().left;
      let offsetY = event.clientY - fauxEntry.getBoundingClientRect().top;
      let index = Array.from(entriesContainer.children).indexOf(realEntry);
      function handleMouseMove(event2) {
        disableObserver(plugin);
        fauxEntry.style.left = event2.clientX - offsetX + "px";
        fauxEntry.style.top = event2.clientY - offsetY + "px";
        const dist = fauxEntry.getBoundingClientRect().top - realEntry.getBoundingClientRect().top;
        if (Math.abs(dist) > realEntry.offsetHeight * 0.75) {
          const dir = dist / Math.abs(dist);
          const newIndex = Math.max(0, Math.min(index + dir, entriesContainer.children.length - 1));
          if (newIndex != index) {
            const passedEntry = entriesContainer.children[newIndex];
            const passedId = passedEntry.getAttribute("data-statusbar-organizer-id");
            const statusBarChangeRequired = elementStatus[statusBarElement.id].exists && elementStatus[passedId].exists;
            const statusBar = document.getElementsByClassName("status-bar")[0];
            if (statusBarChangeRequired && statusBarElement.element) {
              const passedElement = statusBarElements.filter((x) => x.id == passedId)[0].element;
              const temp = passedElement.style.order;
              passedElement.style.order = statusBarElement.element.style.order;
              statusBarElement.element.style.order = temp;
            }
            entriesContainer.removeChild(realEntry);
            if (newIndex != entriesContainer.children.length)
              entriesContainer.insertBefore(realEntry, entriesContainer.children[newIndex]);
            else
              entriesContainer.appendChild(realEntry);
            index = newIndex;
            for (const [entryIndex, entry] of Array.from(entriesContainer.children).entries())
              elementStatus[entry.getAttribute("data-statusbar-organizer-id")].position = entryIndex;
          }
        }
        enableObserver(plugin);
      }
      window.addEventListener("mousemove", handleMouseMove);
      async function handleMouseUp(event2) {
        realEntry.removeClass("statusbar-organizer-clone");
        containerEl.removeChild(fauxEntry);
        dragging = false;
        window.removeEventListener("mouseup", handleMouseUp);
        window.removeEventListener("mousemove", handleMouseMove);
        plugin.settings.status = elementStatus;
        await plugin.saveSettings();
      }
      window.addEventListener("mouseup", handleMouseUp);
    }
    const nameCollisions = {};
    for (const element of statusBarElements) {
      if (element.name in nameCollisions)
        nameCollisions[element.name]++;
      else
        nameCollisions[element.name] = 0;
    }
    for (const statusBarElement of statusBarElements) {
      const currentStatus = elementStatus[statusBarElement.id];
      const entry = document.createElement("div");
      entry.addClass("statusbar-organizer-entry");
      if (!currentStatus.exists)
        entry.addClass("statusbar-organizer-disabled");
      entry.setAttribute("data-statusbar-organizer-id", statusBarElement.id);
      statusBarElement.entry = entry;
      entriesContainer.appendChild(entry);
      const handle = document.createElement("span");
      handle.addClass("statusbar-organizer-handle");
      handle.addEventListener("mousedown", (event) => handleMouseDown(statusBarElement, event, this.plugin));
      entry.appendChild(handle);
      const formattedName = statusBarElement.name.replace(/^plugin-(obsidian-)?/, "").split("-").map((x) => x.charAt(0).toUpperCase() + x.slice(1)).join(" ") + (nameCollisions[statusBarElement.name] ? ` (${statusBarElement.index})` : "");
      const titleSpan = document.createElement("span");
      titleSpan.textContent = formattedName;
      entry.appendChild(titleSpan);
      const previewSpan = document.createElement("span");
      previewSpan.addClass("statusbar-organizer-preview");
      if (currentStatus.exists) {
        previewSpan.innerHTML = statusBarElement.element.innerHTML;
      }
      entry.appendChild(previewSpan);
      const visibilitySpan = document.createElement("span");
      visibilitySpan.addClass("statusbar-organizer-visibility");
      visibilitySpan.onclick = () => {
        if (currentStatus.exists)
          toggleVisibility(statusBarElement, this.plugin);
        else
          removeOrphan(statusBarElement, this.plugin);
      };
      (0, import_obsidian.setIcon)(visibilitySpan, currentStatus.exists ? currentStatus.visible ? "eye" : "eye-off" : "trash-2");
      entry.appendChild(visibilitySpan);
    }
  }
};
